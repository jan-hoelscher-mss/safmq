/*
 Copyright 2004-2008 Matthew J. Battey

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed
	under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
	CONDITIONS OF ANY KIND, either express or implied. See the License for the
	specific language governing permissions and limitations under the License.




This software implements a platform independent C++ interface to TCP/IP socket
communications.
*/
#ifndef _SSLSOCKET_H_
#define _SSLSOCKET_H_

#include "tcpsocket.h"
#include <string>
#include <exception>

namespace tcpsocket {

struct SSLSocketData;


/**
An exception thrown by the SSLSocket class.  This exception
is generated in response to an error generated by the SSL library.
*/
class SSLSocketException : public SocketException {
public:
	/**
	Default Constructor
	*/
    SSLSocketException() throw() {
	}
	/**
	Constructs from a string message
	@param error The error to be represented in this exception
	*/
    SSLSocketException(const char* error)  throw() {
		_what = error;
	}
	/**
	Copy constructor.
	@param src the source exception
	*/
    SSLSocketException(const std::exception& src) throw() {
		*this = src;
	}
	/**
	Copy operator.
	@param src Source object
	@return A reference to this object
	*/
    std::exception& operator= (const std::exception& src) throw() {
		_what = src.what();
		return  *this;
	}
	/**
	Destructor
	*/
    virtual ~SSLSocketException() throw () {
	}
	/**
	Provides the error message.
	@return The error message
	*/
    virtual const char* what() const throw() {
		return _what.c_str();
	}

protected:
	std::string	_what;
};


// forward declaration of the opaque X509 data structure
struct X509Data;

/**
Represents an X509 Certificate object.  This object provides access to
an X509 certificate object.
*/
class X509Certificate 
{
public:
	/// Results of loading a certificate
	enum LoadResult { 
		/// no error occured
		noError,
		/// the file was not found
		fileNotFound, 
		// the file was invalid
		invalidFile };

	X509Certificate();

	X509Certificate(const X509Data* certificate);
	virtual ~X509Certificate();

	std::string getSerialNumber();
	std::string getIssuerName();
	std::string getSubjectName();
	std::string getNotBefore();
	std::string getNotAfter();

	time_t		getNotBefore_time_t();
	time_t		getNotAfter_time_t();


	void* getX509();

	LoadResult loadPEMFile(const std::string& filename, const char* password = NULL);
	LoadResult loadDERFile(const std::string& filename);

	std::string toString();

protected:	// implementation
	time_t	make_time_t(const std::string& datetime, int type);

protected:	// data
	X509Data*	certificate;
};

// forward declaration of the opaque private key data
struct PrivateKeyData;

/**
Class to manage private key values
*/
class PrivateKey
{
public:
	/// Results of loading a certificate
	enum LoadResult { 
		/// no error occured
		noError,
		/// the file was not found
		fileNotFound, 
		// the file was invalid
		invalidFile };

	PrivateKey();
	virtual ~PrivateKey();

	LoadResult loadPEMFile(const std::string& filename, const char* password = NULL);
	LoadResult loadDERFile(const std::string& filename);

	void* get();

protected:
	PrivateKeyData*	pk;
};


/**
Used to specify information about trusted certificate lists (CA files)
*/
class CertificateAuthority
{
public:
	CertificateAuthority(const std::string& caFile = "", const std::string& caDirectory = "");

	std::string getAuthorityFile();
	std::string getAuthorityDirectory();
	void setAuthorityFile(const std::string& caFile);
	void setAuthorityDirectory(const std::string& caDirectory);
protected:
	std::string	caFile;
	std::string caDirectory;
};

class SSLContext;


/**
Implements a Secure Sockets Layer socket connection.
*/
class SSLSocket : public Socket
{
public:
	/// An enumeration SSL Conneciton types indicating whether the object will be used as a client or server
	enum con_type { 
		/// A client connection
		con_client, 
		/// A server connection
		con_server };

	explicit SSLSocket();
	SSLSocket(const SSLSocket& s);
	
	explicit SSLSocket(int socket_handle, SSLContext* pCtx, con_type type = con_client);

	explicit SSLSocket(const char* host, short port, SSLContext* pCtx) throw (SSLSocketException,SocketException);

	virtual ~SSLSocket();

	SSLSocket& operator=(const SSLSocket& s);
	
	virtual size_t send(const char* sendBuffer, size_t length)	throw (SSLSocketException);
	virtual size_t receive(char* readBuffer, size_t length)		throw (SSLSocketException);
	virtual size_t receiveSome(char* readBuffer, size_t length)	throw (SSLSocketException);
	virtual void close() throw (SocketException);

	virtual Socket* clone() const;

	virtual X509Certificate* getPeerCertificate();

	virtual int getVerifyResult();

	virtual std::string getErrorMessage();

	virtual void* getSSL();
	virtual SSLContext* getCTX();

protected:
	void init();
	void init_ssl(SSLContext* pCtx);

	SSLSocketData*	pdata;
};

/**
Implements a Secure Sockets Layer server socket.
*/
class SSLServerSocket : protected SSLSocket
{
public:

	SSLServerSocket(short bindPort, SSLContext* pCtx = NULL, in_addr_t bindAddress = INADDR_ANY, int listenerBacklog = 5) throw (SocketException);
	virtual ~SSLServerSocket() throw (SocketException);

	SSLSocket acceptConnection() throw (SocketException);
	virtual void close() throw (SocketException);
	virtual int getSocket();

	virtual void setCTX(SSLContext* pCtx);
	virtual SSLContext* getCTX();
protected:
	void init(short bindPort, SSLContext* pCtx, in_addr_t bindAddress, int listenerBacklog) throw (SocketException);

protected: // data
	SSLContext*	pCtx;
};


struct SSLContextData;

/**
Establishes a context for establishing and serving Secure Sockets Layer communications.  This
class may be used to dermine client supplied X509 certificates, Trusted Certificate Authorities,
and the SSL version allowed.
*/
class SSLContext
{
public:
	/// An enumeration of SLL versions to use with the <code>SSLSocket</code>
	enum ssl_ver { 
		/// No SSL Version
		none, 
		/// Use SSLv2 when communicating
		sslv2, 
		/// Use SSLv3 when communicating, note the server/client must also use only SSLv3
		sslv3, 
		/// Use SSLv2, SSLv3, or TLS when communicating, communications will start in SSLv2 and then be negotiated to SSLv3 or TLS when using OpenSSL
		sslv23,
		/// USE TLSv1 when communicating
		tlsv1
	};

	SSLContext();
	SSLContext(ssl_ver ver, PrivateKey* pk, X509Certificate* cert, CertificateAuthority *ca);

	virtual ~SSLContext();

	static SSLContext* getDefaultContext() { return &defctx; }


	void*			allocateSSL();

	SSLSocket		allocateSocket(int socket_handle=-1);
	SSLSocket		allocateSocket(const char* host, short port) throw (SSLSocketException,SocketException);
	SSLServerSocket	allocateServerSocket(short bindPort, in_addr_t bindAddress = INADDR_ANY, int listenerBacklog = 5) throw (SocketException);

	void setPrivateKey(PrivateKey *pk);
	PrivateKey* getPrivateKey();

	void setX509Certificate(X509Certificate *cert);
	X509Certificate* getX509Certificate();

	void setCertificateAuthority(CertificateAuthority* ca);
	CertificateAuthority* getCertificateAuthority();

	void setSSLVersion(ssl_ver ver);
	ssl_ver getSSLVersion();

	void setSessionID(const unsigned char* sid, unsigned int sid_len);

	void setVerifyDepth(int verifyDepth);
	int getVerifyDepth();

	void enableVerification(bool requireCert = false);
	void disableVerification();

	virtual int VerifyPeerCertificate(void* x509_store_ctx);


protected:
	void init();

protected:
	SSLContextData			*pdata;

	ssl_ver					ver;
	PrivateKey				*pk;
	X509Certificate			*cert;
	CertificateAuthority	*ca;
	int						verifyDepth;
private:
	static SSLContext		defctx;
};


}

#endif
